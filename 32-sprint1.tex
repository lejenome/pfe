\chapter[Itération~1:~(~2/22/2017~-~3/5/2017~)]{Itération~1:~\textup{\textto{(~2/22/2017~-~3/5/2017~)}}}

La méthodologie Scrum consiste à développer le produit incrémentalement, en
effet chaque itération résulte un prototype ayant des fonctionnalités du
produit demandé livrable. Le développement de ces fonctionnalités se fait
parallèlement puisque les membres de l'équipe avancent dans le même niveau
simultanément. Et ça nécessite de fixer un but commun de l'équipe et de faire
toutes les planifications nécessaires indispensables pour atteindre ce but.

\section{But de l'itération}

Dans le but de définir l'objectif et le périmètre fonctionnel de l'itération 1
et faire sa planification, tous les membres de l'équipe ont participé à un
réunion avec le Product Owner. Vue que l'équipe était encore débutante dans la
méthodologie Scrum et dans l'environnement de travail en équipe, un simple but
était tracer pour cette itération.

Le but de cette itération est de réaliser deux applications mobile et web.
L'application mobile permet simplement de localiser instantanément
l'utilisateur et l'application web montre sa position géographique actuelle
continuellement sur une cartographie avec un marqueur. La
figure~\ref{fig:sprint1-prototype} représente un prototype du produit à
développer.

Pour éteindre ce but, une planification détaillée des tâches a était donnée
durant un réunion de trois heures de travail commun.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\textwidth]{sprint1-prototype}
    \caption{Prototype du produit à développer}
\label{fig:sprint1-prototype}
\end{figure}

%L'objectif de cette itération est d'étudier notre Serveur, de générer notre
%modèle, de réaliser la page Web (dashboard) et développer les vues nécessaires
%pour permettre à l'utilisateur de consulter la dernière position du véhicule
%selon les spécifications du Backlog.

%Une fois la première ébauche du Backlog est réalisée, le Product Owner peut
%découper les spécifications de haut niveau vers des spécifications plus
%raffinées. Dès lors, nous passons à la planification d'une itération. Il est
%important de rappeler que les premières spécifications du Backlog doivent être:

%\begin{itemize}
%    \item assez précise pour être estimée par l'équipe.
%    \item assez petite pour être développée et testée durant une itération.
%\end{itemize}

%Ayant une bonne idée sur le produit ainsi que l'objectif à atteindre, l'équipe
%et le Product Owner peuvent passer à l'élaboration des itérations. Dans notre
%projet \textquote{Plateforme CityWatch}, la durée d'une itération est fixée à
%trois semaines. Dans cette section, nous décrivons le déroulement de la
%première itération. Une itération commence par sa planification et finit par
%être revue avec le \textquote{Product Owner}.

\section{Planification de l'itération}

Pour réaliser le carnet de cette itération, on a décidé de diviser les
fonctionnalités en trois grandes parties:

\begin{enumerate}
    \item Une partie qui s'occupe de l'application mobile et de la détecte du
        position.
    \item Une partie  s'occupe de la partie web et l'affiche de la position
        actuelle sur une cartographie.
    \item Une partie consacré pour la réalisation de la base de données et des
        services web.
\end{enumerate}

\subsection{Backlog de l'Itération}

Pour identifier la liste des taches de cette itération, on a étudié un ensemble
des scénarios qu'on a les décomposés en un ensemble des cas d'utilisations.

\TODO{scénarios + use cases}

Les tâches à réaliser peuvent être soient des tâches de conception, de
développement, de tests, d'intégration et de documentation.

\begin{center}
    \footnotesize
    \begin{longtable}{| p{1cm} | p{5cm} | p{7cm} | p{1cm} |}
        \caption{Backlog de l'itération 1}
\label{tab:sprint1-backlog} \\

        \hline
        \textbf{Réf} & \textbf{Spécification} & \textbf{Description} & \textbf{Priorité} \\ \hline
        \endhead

        \hline \multicolumn{4}{|r|}{{Continué en page suivante$\dotsc$}} \\ \hline
        \endfoot

        \hline \hline
        \endlastfoot

        \hline
1.1 & Présentation et Configuration SVN & Présenter SVN, installer le serveur SVN et créer les répertoires & 1 \\ \hline
1.2 & Recherche sur les Services Web & Présenter les différentes Solutions des services web et choisir la meilleur solution & 1 \\ \hline
1.3 & Implémenter service Save Position & Enregistrement les coordonnées requis dans la base de données & 2 \\ \hline
1.4 & Implémenter la consommation du service Save Position & Coordonnées enregistrés instantané et continuellement dans la BD & 1 \\ \hline
1.5 & Recherche sur les spécifications de la plateforme Android & Présenter le modèle de développement Android et choisir le SDK optimale & 1 \\ \hline
1.6 & Création squelette de l'application mobile & Application fonctionnel (sans les fonctions de localisation) avec l'IHM nécessaire et l'intégration au SVN & 1 \\ \hline
1.7 & Implémenter service Get Last Position & Le serveur retourne les dernières coordonnées requis & 1 \\ \hline
1.8 & Rectification service Save Positon & Support multiple périphériques et enregistrer la date d'envoyé & 2 \\ \hline
1.9 & Rectification service Get Last Position & Retourné la position du périphérique et la date du dernier modification & 2 \\ \hline
1.10 & Affiche Multiple marqueurs & Afficher dernière position de chaque périphérique dans la carte & 2 \\ \hline
1.11 & Affiche état du périphérique & Afficher si le périphérique est en ligne ou hors ligne & 3 \\ \hline
    \end{longtable}
\end{center}

\subsection{Estimation de l'itération}

Avant de commencer le processus d'estimation du temps nécessaire pour la
réalisation de chaque des taches de l'itération, on a fixé la période d'une
itération à trois semaines. On a aussi fixé le budget horaire de chaque membre
comme présenter dans le tableau~\ref{tab:sprint1-capacity}. Le budget horaire
est les heures qu'on va consacrer pour les taches de l'implémentation du
\textquote{City Watch}. Ce budget se calcule généralement par 70\% jusqu'à 80\%
de temps de disponibilité à \textquote{Djagora Academy} vue qu'on a des autres
activités et parfois des heures seront utilisés pour assister à quelques cours.

\begin{table}[htbp]
    \centering
    \begin{tabular}{| c | c | c |}
        \hline
        \textbf{Membre} & \textbf{Nombre d'heures par jour} & \textbf{Budget horaire} \\ \hline
        \hline

Moez & 8 & 140\\ \hline
Rihab & 8 & 140 \\ \hline
\multicolumn{1}{c|}{} & \textbf{Total} & 280 \\ \cline{2-3}
    \end{tabular}
    \caption{Budget horaire --- Itération 1}
\label{tab:sprint1-capacity}
\end{table}

Tout les membres de l'équipe font ensuite l'estimation de temps (en point
d'histoire d'utilisateur) de chaque tâche avec le poker de planning. Les
estimations utilisés sont $\frac{1}{2}$, $1$, $2$, $3$, $5$, $8$, $13$. Les
tâches peuvent aussi être assignées aux plus qu'un seul membres.

Le tableau~\ref{tab:sprint1-estimation} représente les estimations de nos
tâches en heures ($\times2$ signifie que la tâche était assignée à deux membres)
et le membre à qui était assignée la tâche.

\begin{center}
    \begin{longtable}{| l | l | l |}
        \caption{Nombre d'heures estimé pour la réalisation des tâches}
\label{tab:sprint1-estimation} \\

        \hline
        \textbf{Spécification} & \textbf{Membre} & \textbf{Heures} \\ \hline
        \endhead

        \hline \multicolumn{3}{|r|}{{Continué en page suivante$\dotsc$}} \\ \hline
        \endfoot

        \hline \hline
        \endlastfoot

        \hline
Présentation et Configuration SVN & Rihab & 5 $\times$ 2 \\ \hline
Recherche sur les Services Web & Moez & 13 $\times$ 2 \\ \hline
Implémenter service Save Position & Moez & 5 \\ \hline
Implémenter la consommation du service Save Position & Rihab & 5 $\times$ 2 \\ \hline
Recherche sur les spécifications de la plateforme Android & Rihab & 13 $\times$ 2 \\ \hline
Création squelette de l'application mobile & Rihab & 13 \\ \hline
Implémenter service Get Last Position & Moez & 5 \\ \hline
Rectification service Save Positon & Moez & 5 \\ \hline
Rectification service Get Last Position & Moez & 5 \\ \hline
Affiche Multiple marqueurs & Moez & 5 \\ \hline
Affiche état du périphérique & Rihab & 5 \\ \hline
    \end{longtable}
\end{center}

\section{Réalisation de l'application mobile}

Pour réaliser l'application mobile tracé qui contient une interface graphique
simple composée de deux boutons, on a choisi d'étudier la plateforme Android et
de choisir la version SDK optimale pour la réalisation de l'application.

Android nous permet de réaliser des application basé l'astuce d'activité.

\subsection{Activité}

Un utilisateur habile d'Android remarque que lors de l'exploitation d'une
application Android qu'il est en train de naviguer entre des fenêtres et
l'application ne afficher qu'une seule fenêtre à la fois ces fenêtre la sont
des activités on peut différencier ces activité a travers leur interface
graphique ceci s'applique sur la plupart des application Android car il y a des
applications qui contiennent pas d'activités. Un première idée qui nous frappe
la tète c'est que une activité est un conteneur d'élément graphique qui
constitue un interface graphique. Alors que ne non une activité n'est pas
seulement une interface graphique mais elle va établir les liens entre
l'interface graphique et la logique programma tique de plus l'activité contient
des informations sur le statut actuel de l'application qui s'appelle le
contexte ce contexte permet de faire la liaison entre le système Android et les
autres activités de l'application.

\subsubsection{États d'activités}

Le système Android met en place un système priorités entre application par
exemple l'utilisateur est en train de naviguer sur internet et écouter de la
musique il reçois un appel comme l'application qui gère les appel est une
application plus prioritaire elle prend la du navigateur et le lecteur musique
pour que l'utilisateur puisse répondre a son appel. Si une application consomme
trop de ressources et peut bloquer le fonctionnement du système Android,
Android arrêtera cette application. Et aussi comme expliqué précédemment les
activités sont gères a partir d'un système de pile d'activités. D'où
l'apparition de plus d'un état qui sont centré sur l'activité.

On peut différencier ces états par leur visibilité:

\begin{itemize}
    \item État Active.
    \item État en Pause.
    \item État Arrêté.
\end{itemize}

\subsubsection{Cycle de vie d'une activité}

Une activité n'a pas de contrôle sur son état. Son état change suivant un cycle
rythmique entre le système Android et les autres application (un système quasi
dépendant sur des priorités comme expliqué précédemment). La
figure~\ref{fig:android-activity} explique le cycle de vie d'une activité. Les
états sont représentés comme des méthodes parce que lors de la programmation,
ces états sont interroges par le nom de ces méthodes.

\input{figures/android-activity}

\subsubsection{Comment choisir le SDK optimale}

Une SDK permet l'application de marcher sur la version Android visé et les
versions ultérieure il a noté de prendre en considération le taux des
utilisateurs visé par cette application. Aussi il faut travailler avec une SDK
digne de confidence qui n'a pas de problème ou bug qui peuvent bloquer ou
arrêter le fonctionnement de l'application le SDK choisi doit pouvoir supporter
les fonctionnalité offerte par l'application si on va utiliser une
fonctionnalité qui utilise les empreinte le SDK dont on a travailler
l'application doit supporter cette fonctionnalité lorsque le travail sur une
application est en groupe il est mieux que tous ce groupe utilise la même SDK
pour éviter tous problème de compatibilité et conflit entre versions de SDK
donc il faut choisir une SDK qui est populaire en utilisation et qui est
stable. Dans notre projet on va utiliser SDK 23 qui vise la version Android 6.0
ayant un taux d'utilisateur qui est 4.79 \% des utilisateur d'Android notons que
cet SDK comporte la fonctionnalité d'Android les plus récentes et qui est
stable~\cite{android-sdk}.

La figure~\ref{fig:sprint1-android-screenshot} représente l'interface de
l'application réalisé.

Puisque la tache de l'implementation n'était pas mené par un seul personne, on
était obligé d'introduire un systéme synchronisation de notre source code.

\subsection{Apache Subversion}

Les logiciels de gestion de versions \acrshort{VCS} nous permettent de
conserver la chronologie des modifications du source de code, ainsi récupérer
les version intermédiaires et les différences entre eux, et facilitent la
collaboration au développement. Les deux logiciels de gestion de versions les
plus répondus sont Git et Apache SVN\@.

\begin{description}
    \item [Git] Logiciel de gestion de versions distribué avec des branches
        légères. La récupération des versions précédentes et l'enregistrement
        des changements sont possibles sans besoin d'accès au dépôt distant car
        chaque développeur a une copie complète du dépôt. Le modèle Fork
        (Dupliquer), Commit (Modifier), Merge (Fusionner) a eu un grand succès
        dans les projets libres.
    \item [Apache SVN] Logiciel de gestion de versions centralisé. Il est connu
        pour sa simplicité comme il n'est pas un distinct entre un dépôt local
        vs. Dépôt distant, on faire juste une copie du dossier de travail d'une
        version précise. Les commandes sont simples:
        \begin{itemize}
            \item \verb|svn checkin| \ \ vs. \ \ \verb|git commit; git push|
            \item \verb|svn update| \ \ vs. \ \ \verb|git fetch; git rebase|
        \end{itemize}
        Le support du Windows est excellent surtout les outils graphiques. La
        plus tard des fonctionnalités du SVN nécessitent l'accès au dépôt
        (distant).
\end{description}

Apache SVN était choisi pour sa simplicité, sa bon support de Windows et pour
des exigences de spécification.

L'outil serveur choisi est VisualSVN Server pour sa simplicité d'installer et
de configurer et pour son support du Windows.

Les outils clients choisis sont:

\begin{itemize}
    \item TortoiseSVN pour l'intégration avec le système Windows.
    \item La commande de ligne \verb|svn| est utilisée en Linux.
    \item Le support de SVN est intégré au Android Studio et PHPStorm.
\end{itemize}

\section{Réalisation des services web distants}

Pour réaliser les services web, on a étudié les différentes approches et
architectures des ces services web.

Un service web est un protocole d'interface de communication et l'échange de
données entre applications et systèmes hétérogènes à distance en utilisant les
technologies Web (HTTP dans notre cas). Les différentes variantes des
architectures des services web:

\begin{itemize}
    \item Orienté RPC (ex: XML-RPC, SOAP, JSON-RPC):
        \begin{itemize}
            \item Meilleur pour présenter des actions et commandes.
        \end{itemize}
    \item Orienté Ressources (ex: RESTful):
        \begin{itemize}
            \item Représenter les données sous formes des ressources.
            \item Utiliser les méthodes HTTP pour modifier/créer/lire/supprimer
                les données.
            \item Utiliser les paramètres d'URL pour passer des paramètres.
            \item Sans état.
            \item Meilleur pour modéliser un domaine et entités.
        \end{itemize}
\end{itemize}

On a choisi d'utiliser l'architecture RESTful comme notre API est mieux décri
comme ensemble des collections des données dont on peut effectuer avec des
actions CRUD\@.

Avant de commencer la conception et l'implémentation des services web, un
ensemble des exigences ont été définis:

\begin{description}
    \item [Portabilité] Le système doit support la différence en zone du temps
        et en internalisation, format de présentation des données géologique et
        sa précision.
    \item [Stabilité] L'implémentation doit vérifier la structure des données
        reçus, la disponibilité des champs obligatoires et leurs formats.
\end{description}


\subsection{Conception}

La figure~\ref{fig:sprint1-webservices-usecase} ci dessus décrit le diagramme
de cas d'utilisation qui regroupe les scénarios de localisation d'individu.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{sprint1-webservices-usecase}
    \caption{Diagramme de case d'utilisation du services web --- Itération 1}
\label{fig:sprint1-webservices-usecase}
\end{figure}

%\begin{figure}[htbp]
%    \centering
%    \includegraphics[width=0.45\textwidth]{sprint1-webservices-database}
%    \caption{Diagramme entité-association du service Position --- Itération 1}
%\end{figure}

La figure~\ref{fig:sprint1-webservices-post-sequence} décrit le diagramme de
séquence du service \textquote{Post Position} qui représente les scénarios du la
l'envoi de la position.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{sprint1-webservices-post-sequence}
    \caption{Diagramme de séquence du service Post Position --- Itération 1}
\label{fig:sprint1-webservices-post-sequence}
\end{figure}

La figure~\ref{fig:sprint1-webservices-get-sequence} décrit le diagramme de
séquence du service \textquote{Get Position} qui représente les scénarios du
récupère la position.

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{sprint1-webservices-get-sequence}
    \caption{Diagramme de séquence du service Get Position --- Itération 1}
\label{fig:sprint1-webservices-get-sequence}
\end{figure}

\subsection{Services web}

Dans première phase, on a implémenté les méthodes POST et GET du ressource
Position. L'architecture résultante est documentée dans
l'annexe~\ref{appendix:sprint1-position-post-doc}
et~\ref{appendix:sprint1-position-get-doc}.

On a essayé d'adresser les différents exigences spécifiés:

\subsubsection{Probabilité}

On a utilisé la format standardisée JSON~\cite{ECMA-404} pour le transfert de
données ce qui assure la portabilité des représentations des différents types
des données (nombres, booléens, strings, \ldots) indépendant du
l'internationalisation (séparateur décimal, \verb|true| vs. \verb|True| vs.
\verb|vrai| vs. \verb|yes| vs. \verb|y|, \ldots).

Pour le représentation des dates dans le content du requêtes HTTP, on a utilisé
la format RFC3339~\cite{RFC3339} (basé sur ISO8601~\cite{ISO8601} pour
l'utilisation dans les protocols du Web) avec UTC comme la défaut zone du
temps, ex: \verb|2005-08-15T15:52:01Z|.

Pour les en-têtes du requêtes HTTP, la format de représentation des dates est
RFC1123~\cite{RFC1123}, ex: \verb|Mon, 15 Aug 2005 15:52:01 +0000|.

La format du présentation des positions géologique (latitude et longitude)
choisie est la même représentation des nombres en JSON avec une précision
jusqu'à 14 chiffres après le séparateur décimal. Les valeurs envoyés doivent
respecte l'intervalle des diffèrent entités géologiques ($latitude \in [-90,
90]$, $longitude \in [-180, 180]$)

\subsubsection{Stabilité}

Pour assuré la stabilité d'un service web, on doit vérifier la validité de
contenu reçu même si envoyé depuis un source de confiance avant de les
utiliser. La vérification inclue le test de disponibilité des entités
obligatoires et le test de leurs formats.

\section{Revue de cette itération}

À la fin de l'itération, notre équipe et le \textquote{Product Owner} invitées
se réunissent pour effectuer la revue de sprint, qui dure au maximum deux
heures.

L'objectif de la revue de l'itération est de valider l'incrément de produit qui
a été réalisé pendant cette itération. L'équipe énonce les éléments du backlog
en début de sprint, et présente les tâches finis\footnote{complètement
réalisés}. Une démonstration du produit a était fait.

\subsection{Produit de l'itération}

A la fin de l'itération 1, nous avons un première produit partiel permettant de
suivre la position des multiple smartphones et les afficher dans la carte de
notre site web.

\subsubsection{Page Web \textquote{Dashboard}}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{sprint1-dashboard-screenshot}
    \caption{Capture écran de la page web de l'itération 1}
\label{fig:sprint1-dashboard-screenshot}
\end{figure}

La figure~\ref{fig:sprint1-dashboard-screenshot} affiche la position des
individus et son état.

\begin{itemize}
    \item \textit{Marqueur en Vert}: Périphérique en ligne.
    \item \textit{Marqueur en Rouge}:Périphérique en hors ligne.
\end{itemize}



\subsubsection{Application Android}

La figure~\ref{fig:sprint1-android-screenshot} représente l'interface de
l'application réalisé:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.35\textwidth]{sprint1-android-screenshot}
    \caption{Capture écran de l'application dans l'itération 1}
\label{fig:sprint1-android-screenshot}
\end{figure}


\subsection{Avis du Product Owner}

Le Product Owner était ravi des résultats de cette première itération. Il a
validé donc notre travail et nous a encouragé pour l'élaboration des suivantes
itérations.

\subsection{Burndown chart}

La figure~\ref{fig:sprint1-burndown} présente une vue d'ensemble sur le progrès
de notre travail au cours de l'itération par rapport au progrès idéal.

\input{figures/sprint1-burndown}

\subsection{Rétrospectif de l'itération}

Au fin du réunion, les membres de l'équipe a fait un rétrospectif interne pour
créer un plan d'amélioration qui sera mis en place au cours du Sprint suivant.
On a décidé de suivre quelques règles pour assurer la qualité du code.

\begin{itemize}
    \item Activer le mode strict du PHP et changer le mode de traitement des
        erreurs au déclenchement des exceptions si possible (PDO, \ldots).
        Activer le mode strict du JavaScript aussi.
    \item Utiliser des analyseurs statiques du code: PHP\_CodeSniffer, PHPLint
        et ESLint pour détecter les erreurs formelles de programmation ou de
        conception.
    \item Documenter chaque fonction, classe, constante et variable global. On
        a utilisé PHPDoc, apiDoc et JSDoc pour documenter le code PHP, l'api
        RESTful et le code JavaScript respectivement. Pour rédiger les
        recherches, les présentations et les autres documentations, \LaTeX{}
        était préféré avec la possibilité d'utiliser Markdown pour la
        simplisité de son syntaxe.
    \item Écrire les tests unitaires pour les fonctions et les classes selon la
        technique \acrshort{TDD}. On a autorisé l'écrire des tests unitaires
        après le développement du code. Les outils utilisés sont PHPUnit pour
        PHP et Mocha/Chai pour JavaScript.
\end{itemize}

\section*{Conclusion}
\addcontentsline{toc}{section}{Conclusion}

A la fin de cette itération, on avait un prototype minimale fonctionnel
dont on peut baser notre future travail.
L'approche suivi de faire le minimum des tâches pendant la première itération
avait des bon effet sur les membre de notre équipe sur tout la motivation et
la solidarité.

Le tableau~\ref{tab:sprint1-evaluation} présente le pourcentage de
réalisation de nos tâches de cette itération.

\begin{center}
    \begin{longtable}{| l | l |}
        \caption{Liste des tâches réalisées de la première itération}
\label{tab:sprint1-evaluation} \\

        \hline
        \textbf{Les tâches} & \textbf{Taux de réalisation} \\ \hline
        \endhead

        \hline \multicolumn{2}{|r|}{{Continué en page suivante$\dotsc$}} \\ \hline
        \endfoot

        \hline \hline
        \endlastfoot

        \hline
Présentation et Configuration SVN & Effectué 100\% \\ \hline
Recherche sur les Services Web & Effectué 100\% \\ \hline
Implémenter service Save Position & Effectué 100\% \\ \hline
Implémenter la consommation du service Save Position & Effectué 100\% \\ \hline
Recherche sur les spécifications de la plateforme Android & Effectué 100\% \\ \hline
Création squelette de l'application mobile & Effectué 100\% \\ \hline
Implémenter service Get Last Position & Effectué 100\% \\ \hline
Rectification service Save Positon & Effectué 100\% \\ \hline
Rectification service Get Last Position & Effectué 100\% \\ \hline
Affiche Multiple marqueurs & Effectué 100\% \\ \hline
Affiche état du périphérique & Effectué 100\% \\ \hline
    \end{longtable}
\end{center}
